package com.seraphim.pokemon

import android.annotation.SuppressLint
import android.util.Log
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.AutoAwesome
import androidx.compose.material.icons.filled.BookmarkBorder
import androidx.compose.material.icons.filled.CatchingPokemon
import androidx.compose.material.icons.filled.PersonOutline
import androidx.compose.material3.Icon
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.NavigationBar
import androidx.compose.material3.NavigationBarItem
import androidx.compose.material3.Scaffold
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateListOf
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import androidx.compose.runtime.snapshots.SnapshotStateList
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.navigation3.runtime.entry
import androidx.navigation3.runtime.entryProvider
import androidx.navigation3.ui.NavDisplay
import com.seraphim.pokemon.pages.BookmarkScreen
import com.seraphim.pokemon.pages.ExploreScreen
import com.seraphim.pokemon.pages.HomeScreen
import com.seraphim.pokemon.pages.PokemonDetailScreen
import com.seraphim.pokemon.pages.ProfileScreen

private sealed interface TopLevelRoute {
    val icon: ImageVector
    val label: String
}

private data object Home : TopLevelRoute {
    override val icon = Icons.Default.CatchingPokemon;
    override val label = "Home"
}

private data object Bookmark : TopLevelRoute {
    override val icon = Icons.Default.BookmarkBorder;
    override val label = "Bookmark"
}

private data object Explore : TopLevelRoute {
    override val icon = Icons.Default.AutoAwesome;
    override val label = "Explore"
}

private data object Profile : TopLevelRoute {
    override val icon = Icons.Default.PersonOutline;
    override val label = "Profile"
}

private val TOP_LEVEL_ROUTES: List<TopLevelRoute> = listOf(Home, Bookmark, Explore, Profile)


@Composable
@SuppressLint("UnusedMaterial3ScaffoldPaddingParameter")
fun MainScreen() {
    val topLevelBackStack = remember { TopLevelBackStack<Any>(Home) }

    Scaffold(
        bottomBar = {
            if (topLevelBackStack.topLevelKey in listOf(Home, Bookmark, Explore, Profile)) {
                Log.e("MainScreen", "Rendering BottomNavBar for ${topLevelBackStack.topLevelKey}")
                BottomNavBar(topLevelBackStack)
            }
        }) {
        NavDisplay(
            backStack = topLevelBackStack.backStack,
            onBack = { topLevelBackStack.removeLast() },
            entryProvider = entryProvider {
                entry<Home> {
                    HomeScreen(topLevelBackStack)
                }
                entry<Bookmark> {
                    BookmarkScreen()
                }
                entry<Explore> { ExploreScreen() }
                entry<Profile> { ProfileScreen() }
                entry<PokemonDetailRoute> { PokemonDetailScreen((it.pokemon)) }
            })
//        DestinationsNavHost(
//            navController = navController,
//            navGraph = NavGraphs.root, // Automatically generated by Compose Destinations
//            modifier = Modifier.padding(bottom = innerPadding.calculateBottomPadding()),
//            start = NavGraphs.root.defaultStartDirection,
//        )
    }
}

@Composable
fun BottomNavBar(topLevelBackStack: TopLevelBackStack<Any>) {
//    val navigator = topLevelBackStack.rememberDestinationsNavigator()

//    val screens = listOf(
//        BottomNavItem(HomeScreenDestination, Icons.Default.CatchingPokemon, "Home"),
//        BottomNavItem(BookmarkScreenDestination, Icons.Default.BookmarkBorder, "Bookmark"),
//        BottomNavItem(ExploreScreenDestination, Icons.Default.AutoAwesome, "Explore"),
//        BottomNavItem(ProfileScreenDestination, Icons.Default.PersonOutline, "Mine"),
//    )

//    val navBackStackEntry = navController.currentBackStackEntryAsState()
    NavigationBar(containerColor = MaterialTheme.colorScheme.surface) {
        TOP_LEVEL_ROUTES.forEach { topLevelRoute ->
            val isSelected = topLevelRoute == topLevelBackStack.topLevelKey
            NavigationBarItem(selected = isSelected, onClick = {
                topLevelBackStack.addTopLevel(topLevelRoute)
            }, icon = {
                Icon(
                    topLevelRoute.icon, contentDescription = topLevelRoute.label
                )
            }, label = {
                Text(topLevelRoute.label)
            })
        }
    }

}

class TopLevelBackStack<T : Any>(startKey: T) {
    // Maintain a stack for each top level route
    private var topLevelStacks: LinkedHashMap<T, SnapshotStateList<T>> = linkedMapOf(
        startKey to mutableStateListOf(startKey)
    )

    // Expose the current top level route for consumers
    var topLevelKey by mutableStateOf(startKey)
        private set

    // Expose the back stack so it can be rendered by the NavDisplay
    val backStack = mutableStateListOf(startKey)
    private fun updateBackStack() =
        backStack.apply {
            clear()
            addAll(topLevelStacks.flatMap { it.value })
        }

    fun addTopLevel(key: T) {

        // If the top level doesn't exist, add it
        if (topLevelStacks[key] == null) {
            topLevelStacks[key] = mutableStateListOf(key)
        } else {
            // Otherwise just move it to the end of the stacks
            topLevelStacks.apply {
                remove(key)?.let {
                    put(key, it)
                }
            }
        }
        topLevelKey = key
        updateBackStack()
    }

    fun add(key: T) {
        topLevelStacks[topLevelKey]?.add(key)
        updateBackStack()
    }

    fun removeLast() {
        val removedKey = topLevelStacks[topLevelKey]?.removeLastOrNull()
        // If the removed key was a top level key, remove the associated top level stack
        topLevelStacks.remove(removedKey)
        topLevelKey = topLevelStacks.keys.last()
        updateBackStack()
    }
}